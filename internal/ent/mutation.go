// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/empiricaly/recruitment/internal/ent/admin"
	"github.com/empiricaly/recruitment/internal/ent/datum"
	"github.com/empiricaly/recruitment/internal/ent/participant"
	"github.com/empiricaly/recruitment/internal/ent/participation"
	"github.com/empiricaly/recruitment/internal/ent/project"
	"github.com/empiricaly/recruitment/internal/ent/providerid"
	"github.com/empiricaly/recruitment/internal/ent/run"
	"github.com/empiricaly/recruitment/internal/ent/step"
	"github.com/empiricaly/recruitment/internal/ent/steprun"
	"github.com/empiricaly/recruitment/internal/ent/template"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin         = "Admin"
	TypeDatum         = "Datum"
	TypeParticipant   = "Participant"
	TypeParticipation = "Participation"
	TypeProject       = "Project"
	TypeProviderID    = "ProviderID"
	TypeRun           = "Run"
	TypeStep          = "Step"
	TypeStepRun       = "StepRun"
	TypeTemplate      = "Template"
)

// AdminMutation represents an operation that mutate the Admins
// nodes in the graph.
type AdminMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	username         *string
	clearedFields    map[string]struct{}
	projects         map[string]struct{}
	removedprojects  map[string]struct{}
	clearedprojects  bool
	templates        map[string]struct{}
	removedtemplates map[string]struct{}
	clearedtemplates bool
	done             bool
	oldValue         func(context.Context) (*Admin, error)
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows to manage the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for $n.Name.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the id field of the mutation.
func withAdminID(id string) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Admin creation.
func (m *AdminMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AdminMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Admin.
// If the Admin object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Admin.
// If the Admin object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *AdminMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AdminMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Admin.
// If the Admin object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AdminMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AdminMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the username field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old username value of the Admin.
// If the Admin object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// AddProjectIDs adds the projects edge to Project by ids.
func (m *AdminMutation) AddProjectIDs(ids ...string) {
	if m.projects == nil {
		m.projects = make(map[string]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the projects edge to Project.
func (m *AdminMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared returns if the edge projects was cleared.
func (m *AdminMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the projects edge to Project by ids.
func (m *AdminMutation) RemoveProjectIDs(ids ...string) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[string]struct{})
	}
	for i := range ids {
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed ids of projects.
func (m *AdminMutation) RemovedProjectsIDs() (ids []string) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the projects ids in the mutation.
func (m *AdminMutation) ProjectsIDs() (ids []string) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects reset all changes of the "projects" edge.
func (m *AdminMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddTemplateIDs adds the templates edge to Template by ids.
func (m *AdminMutation) AddTemplateIDs(ids ...string) {
	if m.templates == nil {
		m.templates = make(map[string]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the templates edge to Template.
func (m *AdminMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared returns if the edge templates was cleared.
func (m *AdminMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the templates edge to Template by ids.
func (m *AdminMutation) RemoveTemplateIDs(ids ...string) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[string]struct{})
	}
	for i := range ids {
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed ids of templates.
func (m *AdminMutation) RemovedTemplatesIDs() (ids []string) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the templates ids in the mutation.
func (m *AdminMutation) TemplatesIDs() (ids []string) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates reset all changes of the "templates" edge.
func (m *AdminMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, admin.FieldName)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldName:
		return m.Name()
	case admin.FieldUsername:
		return m.Username()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldName:
		return m.OldName(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AdminMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldName:
		m.ResetName()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.projects != nil {
		edges = append(edges, admin.EdgeProjects)
	}
	if m.templates != nil {
		edges = append(edges, admin.EdgeTemplates)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojects != nil {
		edges = append(edges, admin.EdgeProjects)
	}
	if m.removedtemplates != nil {
		edges = append(edges, admin.EdgeTemplates)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprojects {
		edges = append(edges, admin.EdgeProjects)
	}
	if m.clearedtemplates {
		edges = append(edges, admin.EdgeTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeProjects:
		return m.clearedprojects
	case admin.EdgeTemplates:
		return m.clearedtemplates
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeProjects:
		m.ResetProjects()
		return nil
	case admin.EdgeTemplates:
		m.ResetTemplates()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// DatumMutation represents an operation that mutate the Data
// nodes in the graph.
type DatumMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	key                *string
	val                *[]byte
	index              *int
	addindex           *int
	current            *bool
	version            *int
	addversion         *int
	deletedAt          *time.Time
	clearedFields      map[string]struct{}
	participant        *string
	clearedparticipant bool
	done               bool
	oldValue           func(context.Context) (*Datum, error)
}

var _ ent.Mutation = (*DatumMutation)(nil)

// datumOption allows to manage the mutation configuration using functional options.
type datumOption func(*DatumMutation)

// newDatumMutation creates new mutation for $n.Name.
func newDatumMutation(c config, op Op, opts ...datumOption) *DatumMutation {
	m := &DatumMutation{
		config:        c,
		op:            op,
		typ:           TypeDatum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDatumID sets the id field of the mutation.
func withDatumID(id string) datumOption {
	return func(m *DatumMutation) {
		var (
			err   error
			once  sync.Once
			value *Datum
		)
		m.oldValue = func(ctx context.Context) (*Datum, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Datum.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDatum sets the old Datum of the mutation.
func withDatum(node *Datum) datumOption {
	return func(m *DatumMutation) {
		m.oldValue = func(context.Context) (*Datum, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DatumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DatumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Datum creation.
func (m *DatumMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DatumMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *DatumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *DatumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *DatumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *DatumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *DatumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *DatumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the key field.
func (m *DatumMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the key value in the mutation.
func (m *DatumMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old key value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey reset all changes of the "key" field.
func (m *DatumMutation) ResetKey() {
	m.key = nil
}

// SetVal sets the val field.
func (m *DatumMutation) SetVal(b []byte) {
	m.val = &b
}

// Val returns the val value in the mutation.
func (m *DatumMutation) Val() (r []byte, exists bool) {
	v := m.val
	if v == nil {
		return
	}
	return *v, true
}

// OldVal returns the old val value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldVal(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVal: %w", err)
	}
	return oldValue.Val, nil
}

// ResetVal reset all changes of the "val" field.
func (m *DatumMutation) ResetVal() {
	m.val = nil
}

// SetIndex sets the index field.
func (m *DatumMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *DatumMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *DatumMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *DatumMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *DatumMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetCurrent sets the current field.
func (m *DatumMutation) SetCurrent(b bool) {
	m.current = &b
}

// Current returns the current value in the mutation.
func (m *DatumMutation) Current() (r bool, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old current value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// ResetCurrent reset all changes of the "current" field.
func (m *DatumMutation) ResetCurrent() {
	m.current = nil
}

// SetVersion sets the version field.
func (m *DatumMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *DatumMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *DatumMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *DatumMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *DatumMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetDeletedAt sets the deletedAt field.
func (m *DatumMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the deletedAt value in the mutation.
func (m *DatumMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deletedAt value of the Datum.
// If the Datum object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DatumMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deletedAt.
func (m *DatumMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[datum.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deletedAt was cleared in this mutation.
func (m *DatumMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[datum.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deletedAt" field.
func (m *DatumMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, datum.FieldDeletedAt)
}

// SetParticipantID sets the participant edge to Participant by id.
func (m *DatumMutation) SetParticipantID(id string) {
	m.participant = &id
}

// ClearParticipant clears the participant edge to Participant.
func (m *DatumMutation) ClearParticipant() {
	m.clearedparticipant = true
}

// ParticipantCleared returns if the edge participant was cleared.
func (m *DatumMutation) ParticipantCleared() bool {
	return m.clearedparticipant
}

// ParticipantID returns the participant id in the mutation.
func (m *DatumMutation) ParticipantID() (id string, exists bool) {
	if m.participant != nil {
		return *m.participant, true
	}
	return
}

// ParticipantIDs returns the participant ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParticipantID instead. It exists only for internal usage by the builders.
func (m *DatumMutation) ParticipantIDs() (ids []string) {
	if id := m.participant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParticipant reset all changes of the "participant" edge.
func (m *DatumMutation) ResetParticipant() {
	m.participant = nil
	m.clearedparticipant = false
}

// Op returns the operation name.
func (m *DatumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Datum).
func (m *DatumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DatumMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, datum.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, datum.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, datum.FieldKey)
	}
	if m.val != nil {
		fields = append(fields, datum.FieldVal)
	}
	if m.index != nil {
		fields = append(fields, datum.FieldIndex)
	}
	if m.current != nil {
		fields = append(fields, datum.FieldCurrent)
	}
	if m.version != nil {
		fields = append(fields, datum.FieldVersion)
	}
	if m.deletedAt != nil {
		fields = append(fields, datum.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DatumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case datum.FieldCreatedAt:
		return m.CreatedAt()
	case datum.FieldUpdatedAt:
		return m.UpdatedAt()
	case datum.FieldKey:
		return m.Key()
	case datum.FieldVal:
		return m.Val()
	case datum.FieldIndex:
		return m.Index()
	case datum.FieldCurrent:
		return m.Current()
	case datum.FieldVersion:
		return m.Version()
	case datum.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DatumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case datum.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case datum.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case datum.FieldKey:
		return m.OldKey(ctx)
	case datum.FieldVal:
		return m.OldVal(ctx)
	case datum.FieldIndex:
		return m.OldIndex(ctx)
	case datum.FieldCurrent:
		return m.OldCurrent(ctx)
	case datum.FieldVersion:
		return m.OldVersion(ctx)
	case datum.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Datum field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DatumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case datum.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case datum.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case datum.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case datum.FieldVal:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVal(v)
		return nil
	case datum.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case datum.FieldCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case datum.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case datum.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Datum field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DatumMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, datum.FieldIndex)
	}
	if m.addversion != nil {
		fields = append(fields, datum.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DatumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case datum.FieldIndex:
		return m.AddedIndex()
	case datum.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DatumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case datum.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case datum.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Datum numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DatumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(datum.FieldDeletedAt) {
		fields = append(fields, datum.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DatumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DatumMutation) ClearField(name string) error {
	switch name {
	case datum.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Datum nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DatumMutation) ResetField(name string) error {
	switch name {
	case datum.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case datum.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case datum.FieldKey:
		m.ResetKey()
		return nil
	case datum.FieldVal:
		m.ResetVal()
		return nil
	case datum.FieldIndex:
		m.ResetIndex()
		return nil
	case datum.FieldCurrent:
		m.ResetCurrent()
		return nil
	case datum.FieldVersion:
		m.ResetVersion()
		return nil
	case datum.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Datum field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DatumMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.participant != nil {
		edges = append(edges, datum.EdgeParticipant)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DatumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case datum.EdgeParticipant:
		if id := m.participant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DatumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DatumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DatumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparticipant {
		edges = append(edges, datum.EdgeParticipant)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DatumMutation) EdgeCleared(name string) bool {
	switch name {
	case datum.EdgeParticipant:
		return m.clearedparticipant
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DatumMutation) ClearEdge(name string) error {
	switch name {
	case datum.EdgeParticipant:
		m.ClearParticipant()
		return nil
	}
	return fmt.Errorf("unknown Datum unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DatumMutation) ResetEdge(name string) error {
	switch name {
	case datum.EdgeParticipant:
		m.ResetParticipant()
		return nil
	}
	return fmt.Errorf("unknown Datum edge %s", name)
}

// ParticipantMutation represents an operation that mutate the Participants
// nodes in the graph.
type ParticipantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	mturkWorkerID         *string
	clearedFields         map[string]struct{}
	data                  map[string]struct{}
	removeddata           map[string]struct{}
	cleareddata           bool
	providerIDs           map[string]struct{}
	removedproviderIDs    map[string]struct{}
	clearedproviderIDs    bool
	participations        map[string]struct{}
	removedparticipations map[string]struct{}
	clearedparticipations bool
	createdBy             *string
	clearedcreatedBy      bool
	steps                 map[string]struct{}
	removedsteps          map[string]struct{}
	clearedsteps          bool
	done                  bool
	oldValue              func(context.Context) (*Participant, error)
}

var _ ent.Mutation = (*ParticipantMutation)(nil)

// participantOption allows to manage the mutation configuration using functional options.
type participantOption func(*ParticipantMutation)

// newParticipantMutation creates new mutation for $n.Name.
func newParticipantMutation(c config, op Op, opts ...participantOption) *ParticipantMutation {
	m := &ParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParticipantID sets the id field of the mutation.
func withParticipantID(id string) participantOption {
	return func(m *ParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *Participant
		)
		m.oldValue = func(ctx context.Context) (*Participant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Participant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParticipant sets the old Participant of the mutation.
func withParticipant(node *Participant) participantOption {
	return func(m *ParticipantMutation) {
		m.oldValue = func(context.Context) (*Participant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Participant creation.
func (m *ParticipantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ParticipantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Participant.
// If the Participant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Participant.
// If the Participant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMturkWorkerID sets the mturkWorkerID field.
func (m *ParticipantMutation) SetMturkWorkerID(s string) {
	m.mturkWorkerID = &s
}

// MturkWorkerID returns the mturkWorkerID value in the mutation.
func (m *ParticipantMutation) MturkWorkerID() (r string, exists bool) {
	v := m.mturkWorkerID
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkWorkerID returns the old mturkWorkerID value of the Participant.
// If the Participant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipantMutation) OldMturkWorkerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkWorkerID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkWorkerID: %w", err)
	}
	return oldValue.MturkWorkerID, nil
}

// ClearMturkWorkerID clears the value of mturkWorkerID.
func (m *ParticipantMutation) ClearMturkWorkerID() {
	m.mturkWorkerID = nil
	m.clearedFields[participant.FieldMturkWorkerID] = struct{}{}
}

// MturkWorkerIDCleared returns if the field mturkWorkerID was cleared in this mutation.
func (m *ParticipantMutation) MturkWorkerIDCleared() bool {
	_, ok := m.clearedFields[participant.FieldMturkWorkerID]
	return ok
}

// ResetMturkWorkerID reset all changes of the "mturkWorkerID" field.
func (m *ParticipantMutation) ResetMturkWorkerID() {
	m.mturkWorkerID = nil
	delete(m.clearedFields, participant.FieldMturkWorkerID)
}

// AddDatumIDs adds the data edge to Datum by ids.
func (m *ParticipantMutation) AddDatumIDs(ids ...string) {
	if m.data == nil {
		m.data = make(map[string]struct{})
	}
	for i := range ids {
		m.data[ids[i]] = struct{}{}
	}
}

// ClearData clears the data edge to Datum.
func (m *ParticipantMutation) ClearData() {
	m.cleareddata = true
}

// DataCleared returns if the edge data was cleared.
func (m *ParticipantMutation) DataCleared() bool {
	return m.cleareddata
}

// RemoveDatumIDs removes the data edge to Datum by ids.
func (m *ParticipantMutation) RemoveDatumIDs(ids ...string) {
	if m.removeddata == nil {
		m.removeddata = make(map[string]struct{})
	}
	for i := range ids {
		m.removeddata[ids[i]] = struct{}{}
	}
}

// RemovedData returns the removed ids of data.
func (m *ParticipantMutation) RemovedDataIDs() (ids []string) {
	for id := range m.removeddata {
		ids = append(ids, id)
	}
	return
}

// DataIDs returns the data ids in the mutation.
func (m *ParticipantMutation) DataIDs() (ids []string) {
	for id := range m.data {
		ids = append(ids, id)
	}
	return
}

// ResetData reset all changes of the "data" edge.
func (m *ParticipantMutation) ResetData() {
	m.data = nil
	m.cleareddata = false
	m.removeddata = nil
}

// AddProviderIDIDs adds the providerIDs edge to ProviderID by ids.
func (m *ParticipantMutation) AddProviderIDIDs(ids ...string) {
	if m.providerIDs == nil {
		m.providerIDs = make(map[string]struct{})
	}
	for i := range ids {
		m.providerIDs[ids[i]] = struct{}{}
	}
}

// ClearProviderIDs clears the providerIDs edge to ProviderID.
func (m *ParticipantMutation) ClearProviderIDs() {
	m.clearedproviderIDs = true
}

// ProviderIDsCleared returns if the edge providerIDs was cleared.
func (m *ParticipantMutation) ProviderIDsCleared() bool {
	return m.clearedproviderIDs
}

// RemoveProviderIDIDs removes the providerIDs edge to ProviderID by ids.
func (m *ParticipantMutation) RemoveProviderIDIDs(ids ...string) {
	if m.removedproviderIDs == nil {
		m.removedproviderIDs = make(map[string]struct{})
	}
	for i := range ids {
		m.removedproviderIDs[ids[i]] = struct{}{}
	}
}

// RemovedProviderIDs returns the removed ids of providerIDs.
func (m *ParticipantMutation) RemovedProviderIDsIDs() (ids []string) {
	for id := range m.removedproviderIDs {
		ids = append(ids, id)
	}
	return
}

// ProviderIDsIDs returns the providerIDs ids in the mutation.
func (m *ParticipantMutation) ProviderIDsIDs() (ids []string) {
	for id := range m.providerIDs {
		ids = append(ids, id)
	}
	return
}

// ResetProviderIDs reset all changes of the "providerIDs" edge.
func (m *ParticipantMutation) ResetProviderIDs() {
	m.providerIDs = nil
	m.clearedproviderIDs = false
	m.removedproviderIDs = nil
}

// AddParticipationIDs adds the participations edge to Participation by ids.
func (m *ParticipantMutation) AddParticipationIDs(ids ...string) {
	if m.participations == nil {
		m.participations = make(map[string]struct{})
	}
	for i := range ids {
		m.participations[ids[i]] = struct{}{}
	}
}

// ClearParticipations clears the participations edge to Participation.
func (m *ParticipantMutation) ClearParticipations() {
	m.clearedparticipations = true
}

// ParticipationsCleared returns if the edge participations was cleared.
func (m *ParticipantMutation) ParticipationsCleared() bool {
	return m.clearedparticipations
}

// RemoveParticipationIDs removes the participations edge to Participation by ids.
func (m *ParticipantMutation) RemoveParticipationIDs(ids ...string) {
	if m.removedparticipations == nil {
		m.removedparticipations = make(map[string]struct{})
	}
	for i := range ids {
		m.removedparticipations[ids[i]] = struct{}{}
	}
}

// RemovedParticipations returns the removed ids of participations.
func (m *ParticipantMutation) RemovedParticipationsIDs() (ids []string) {
	for id := range m.removedparticipations {
		ids = append(ids, id)
	}
	return
}

// ParticipationsIDs returns the participations ids in the mutation.
func (m *ParticipantMutation) ParticipationsIDs() (ids []string) {
	for id := range m.participations {
		ids = append(ids, id)
	}
	return
}

// ResetParticipations reset all changes of the "participations" edge.
func (m *ParticipantMutation) ResetParticipations() {
	m.participations = nil
	m.clearedparticipations = false
	m.removedparticipations = nil
}

// SetCreatedByID sets the createdBy edge to StepRun by id.
func (m *ParticipantMutation) SetCreatedByID(id string) {
	m.createdBy = &id
}

// ClearCreatedBy clears the createdBy edge to StepRun.
func (m *ParticipantMutation) ClearCreatedBy() {
	m.clearedcreatedBy = true
}

// CreatedByCleared returns if the edge createdBy was cleared.
func (m *ParticipantMutation) CreatedByCleared() bool {
	return m.clearedcreatedBy
}

// CreatedByID returns the createdBy id in the mutation.
func (m *ParticipantMutation) CreatedByID() (id string, exists bool) {
	if m.createdBy != nil {
		return *m.createdBy, true
	}
	return
}

// CreatedByIDs returns the createdBy ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ParticipantMutation) CreatedByIDs() (ids []string) {
	if id := m.createdBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy reset all changes of the "createdBy" edge.
func (m *ParticipantMutation) ResetCreatedBy() {
	m.createdBy = nil
	m.clearedcreatedBy = false
}

// AddStepIDs adds the steps edge to StepRun by ids.
func (m *ParticipantMutation) AddStepIDs(ids ...string) {
	if m.steps == nil {
		m.steps = make(map[string]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the steps edge to StepRun.
func (m *ParticipantMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared returns if the edge steps was cleared.
func (m *ParticipantMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the steps edge to StepRun by ids.
func (m *ParticipantMutation) RemoveStepIDs(ids ...string) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[string]struct{})
	}
	for i := range ids {
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed ids of steps.
func (m *ParticipantMutation) RemovedStepsIDs() (ids []string) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the steps ids in the mutation.
func (m *ParticipantMutation) StepsIDs() (ids []string) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps reset all changes of the "steps" edge.
func (m *ParticipantMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// Op returns the operation name.
func (m *ParticipantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Participant).
func (m *ParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ParticipantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, participant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, participant.FieldUpdatedAt)
	}
	if m.mturkWorkerID != nil {
		fields = append(fields, participant.FieldMturkWorkerID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case participant.FieldCreatedAt:
		return m.CreatedAt()
	case participant.FieldUpdatedAt:
		return m.UpdatedAt()
	case participant.FieldMturkWorkerID:
		return m.MturkWorkerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case participant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case participant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case participant.FieldMturkWorkerID:
		return m.OldMturkWorkerID(ctx)
	}
	return nil, fmt.Errorf("unknown Participant field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case participant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case participant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case participant.FieldMturkWorkerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkWorkerID(v)
		return nil
	}
	return fmt.Errorf("unknown Participant field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Participant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(participant.FieldMturkWorkerID) {
		fields = append(fields, participant.FieldMturkWorkerID)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParticipantMutation) ClearField(name string) error {
	switch name {
	case participant.FieldMturkWorkerID:
		m.ClearMturkWorkerID()
		return nil
	}
	return fmt.Errorf("unknown Participant nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ParticipantMutation) ResetField(name string) error {
	switch name {
	case participant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case participant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case participant.FieldMturkWorkerID:
		m.ResetMturkWorkerID()
		return nil
	}
	return fmt.Errorf("unknown Participant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.data != nil {
		edges = append(edges, participant.EdgeData)
	}
	if m.providerIDs != nil {
		edges = append(edges, participant.EdgeProviderIDs)
	}
	if m.participations != nil {
		edges = append(edges, participant.EdgeParticipations)
	}
	if m.createdBy != nil {
		edges = append(edges, participant.EdgeCreatedBy)
	}
	if m.steps != nil {
		edges = append(edges, participant.EdgeSteps)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case participant.EdgeData:
		ids := make([]ent.Value, 0, len(m.data))
		for id := range m.data {
			ids = append(ids, id)
		}
		return ids
	case participant.EdgeProviderIDs:
		ids := make([]ent.Value, 0, len(m.providerIDs))
		for id := range m.providerIDs {
			ids = append(ids, id)
		}
		return ids
	case participant.EdgeParticipations:
		ids := make([]ent.Value, 0, len(m.participations))
		for id := range m.participations {
			ids = append(ids, id)
		}
		return ids
	case participant.EdgeCreatedBy:
		if id := m.createdBy; id != nil {
			return []ent.Value{*id}
		}
	case participant.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddata != nil {
		edges = append(edges, participant.EdgeData)
	}
	if m.removedproviderIDs != nil {
		edges = append(edges, participant.EdgeProviderIDs)
	}
	if m.removedparticipations != nil {
		edges = append(edges, participant.EdgeParticipations)
	}
	if m.removedsteps != nil {
		edges = append(edges, participant.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case participant.EdgeData:
		ids := make([]ent.Value, 0, len(m.removeddata))
		for id := range m.removeddata {
			ids = append(ids, id)
		}
		return ids
	case participant.EdgeProviderIDs:
		ids := make([]ent.Value, 0, len(m.removedproviderIDs))
		for id := range m.removedproviderIDs {
			ids = append(ids, id)
		}
		return ids
	case participant.EdgeParticipations:
		ids := make([]ent.Value, 0, len(m.removedparticipations))
		for id := range m.removedparticipations {
			ids = append(ids, id)
		}
		return ids
	case participant.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddata {
		edges = append(edges, participant.EdgeData)
	}
	if m.clearedproviderIDs {
		edges = append(edges, participant.EdgeProviderIDs)
	}
	if m.clearedparticipations {
		edges = append(edges, participant.EdgeParticipations)
	}
	if m.clearedcreatedBy {
		edges = append(edges, participant.EdgeCreatedBy)
	}
	if m.clearedsteps {
		edges = append(edges, participant.EdgeSteps)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case participant.EdgeData:
		return m.cleareddata
	case participant.EdgeProviderIDs:
		return m.clearedproviderIDs
	case participant.EdgeParticipations:
		return m.clearedparticipations
	case participant.EdgeCreatedBy:
		return m.clearedcreatedBy
	case participant.EdgeSteps:
		return m.clearedsteps
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ParticipantMutation) ClearEdge(name string) error {
	switch name {
	case participant.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Participant unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ParticipantMutation) ResetEdge(name string) error {
	switch name {
	case participant.EdgeData:
		m.ResetData()
		return nil
	case participant.EdgeProviderIDs:
		m.ResetProviderIDs()
		return nil
	case participant.EdgeParticipations:
		m.ResetParticipations()
		return nil
	case participant.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case participant.EdgeSteps:
		m.ResetSteps()
		return nil
	}
	return fmt.Errorf("unknown Participant edge %s", name)
}

// ParticipationMutation represents an operation that mutate the Participations
// nodes in the graph.
type ParticipationMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	mturkWorkerID      *string
	mturkAssignmentID  *string
	mturkHitID         *string
	mturkAcceptedAt    *time.Time
	mturkSubmittedAt   *time.Time
	clearedFields      map[string]struct{}
	stepRun            *string
	clearedstepRun     bool
	participant        *string
	clearedparticipant bool
	done               bool
	oldValue           func(context.Context) (*Participation, error)
}

var _ ent.Mutation = (*ParticipationMutation)(nil)

// participationOption allows to manage the mutation configuration using functional options.
type participationOption func(*ParticipationMutation)

// newParticipationMutation creates new mutation for $n.Name.
func newParticipationMutation(c config, op Op, opts ...participationOption) *ParticipationMutation {
	m := &ParticipationMutation{
		config:        c,
		op:            op,
		typ:           TypeParticipation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParticipationID sets the id field of the mutation.
func withParticipationID(id string) participationOption {
	return func(m *ParticipationMutation) {
		var (
			err   error
			once  sync.Once
			value *Participation
		)
		m.oldValue = func(ctx context.Context) (*Participation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Participation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParticipation sets the old Participation of the mutation.
func withParticipation(node *Participation) participationOption {
	return func(m *ParticipationMutation) {
		m.oldValue = func(context.Context) (*Participation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParticipationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParticipationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Participation creation.
func (m *ParticipationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ParticipationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ParticipationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ParticipationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Participation.
// If the Participation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ParticipationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ParticipationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ParticipationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Participation.
// If the Participation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ParticipationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMturkWorkerID sets the mturkWorkerID field.
func (m *ParticipationMutation) SetMturkWorkerID(s string) {
	m.mturkWorkerID = &s
}

// MturkWorkerID returns the mturkWorkerID value in the mutation.
func (m *ParticipationMutation) MturkWorkerID() (r string, exists bool) {
	v := m.mturkWorkerID
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkWorkerID returns the old mturkWorkerID value of the Participation.
// If the Participation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipationMutation) OldMturkWorkerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkWorkerID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkWorkerID: %w", err)
	}
	return oldValue.MturkWorkerID, nil
}

// ResetMturkWorkerID reset all changes of the "mturkWorkerID" field.
func (m *ParticipationMutation) ResetMturkWorkerID() {
	m.mturkWorkerID = nil
}

// SetMturkAssignmentID sets the mturkAssignmentID field.
func (m *ParticipationMutation) SetMturkAssignmentID(s string) {
	m.mturkAssignmentID = &s
}

// MturkAssignmentID returns the mturkAssignmentID value in the mutation.
func (m *ParticipationMutation) MturkAssignmentID() (r string, exists bool) {
	v := m.mturkAssignmentID
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkAssignmentID returns the old mturkAssignmentID value of the Participation.
// If the Participation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipationMutation) OldMturkAssignmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkAssignmentID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkAssignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkAssignmentID: %w", err)
	}
	return oldValue.MturkAssignmentID, nil
}

// ResetMturkAssignmentID reset all changes of the "mturkAssignmentID" field.
func (m *ParticipationMutation) ResetMturkAssignmentID() {
	m.mturkAssignmentID = nil
}

// SetMturkHitID sets the mturkHitID field.
func (m *ParticipationMutation) SetMturkHitID(s string) {
	m.mturkHitID = &s
}

// MturkHitID returns the mturkHitID value in the mutation.
func (m *ParticipationMutation) MturkHitID() (r string, exists bool) {
	v := m.mturkHitID
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkHitID returns the old mturkHitID value of the Participation.
// If the Participation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipationMutation) OldMturkHitID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkHitID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkHitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkHitID: %w", err)
	}
	return oldValue.MturkHitID, nil
}

// ResetMturkHitID reset all changes of the "mturkHitID" field.
func (m *ParticipationMutation) ResetMturkHitID() {
	m.mturkHitID = nil
}

// SetMturkAcceptedAt sets the mturkAcceptedAt field.
func (m *ParticipationMutation) SetMturkAcceptedAt(t time.Time) {
	m.mturkAcceptedAt = &t
}

// MturkAcceptedAt returns the mturkAcceptedAt value in the mutation.
func (m *ParticipationMutation) MturkAcceptedAt() (r time.Time, exists bool) {
	v := m.mturkAcceptedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkAcceptedAt returns the old mturkAcceptedAt value of the Participation.
// If the Participation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipationMutation) OldMturkAcceptedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkAcceptedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkAcceptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkAcceptedAt: %w", err)
	}
	return oldValue.MturkAcceptedAt, nil
}

// ResetMturkAcceptedAt reset all changes of the "mturkAcceptedAt" field.
func (m *ParticipationMutation) ResetMturkAcceptedAt() {
	m.mturkAcceptedAt = nil
}

// SetMturkSubmittedAt sets the mturkSubmittedAt field.
func (m *ParticipationMutation) SetMturkSubmittedAt(t time.Time) {
	m.mturkSubmittedAt = &t
}

// MturkSubmittedAt returns the mturkSubmittedAt value in the mutation.
func (m *ParticipationMutation) MturkSubmittedAt() (r time.Time, exists bool) {
	v := m.mturkSubmittedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkSubmittedAt returns the old mturkSubmittedAt value of the Participation.
// If the Participation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParticipationMutation) OldMturkSubmittedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkSubmittedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkSubmittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkSubmittedAt: %w", err)
	}
	return oldValue.MturkSubmittedAt, nil
}

// ResetMturkSubmittedAt reset all changes of the "mturkSubmittedAt" field.
func (m *ParticipationMutation) ResetMturkSubmittedAt() {
	m.mturkSubmittedAt = nil
}

// SetStepRunID sets the stepRun edge to StepRun by id.
func (m *ParticipationMutation) SetStepRunID(id string) {
	m.stepRun = &id
}

// ClearStepRun clears the stepRun edge to StepRun.
func (m *ParticipationMutation) ClearStepRun() {
	m.clearedstepRun = true
}

// StepRunCleared returns if the edge stepRun was cleared.
func (m *ParticipationMutation) StepRunCleared() bool {
	return m.clearedstepRun
}

// StepRunID returns the stepRun id in the mutation.
func (m *ParticipationMutation) StepRunID() (id string, exists bool) {
	if m.stepRun != nil {
		return *m.stepRun, true
	}
	return
}

// StepRunIDs returns the stepRun ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StepRunID instead. It exists only for internal usage by the builders.
func (m *ParticipationMutation) StepRunIDs() (ids []string) {
	if id := m.stepRun; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStepRun reset all changes of the "stepRun" edge.
func (m *ParticipationMutation) ResetStepRun() {
	m.stepRun = nil
	m.clearedstepRun = false
}

// SetParticipantID sets the participant edge to Participant by id.
func (m *ParticipationMutation) SetParticipantID(id string) {
	m.participant = &id
}

// ClearParticipant clears the participant edge to Participant.
func (m *ParticipationMutation) ClearParticipant() {
	m.clearedparticipant = true
}

// ParticipantCleared returns if the edge participant was cleared.
func (m *ParticipationMutation) ParticipantCleared() bool {
	return m.clearedparticipant
}

// ParticipantID returns the participant id in the mutation.
func (m *ParticipationMutation) ParticipantID() (id string, exists bool) {
	if m.participant != nil {
		return *m.participant, true
	}
	return
}

// ParticipantIDs returns the participant ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParticipantID instead. It exists only for internal usage by the builders.
func (m *ParticipationMutation) ParticipantIDs() (ids []string) {
	if id := m.participant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParticipant reset all changes of the "participant" edge.
func (m *ParticipationMutation) ResetParticipant() {
	m.participant = nil
	m.clearedparticipant = false
}

// Op returns the operation name.
func (m *ParticipationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Participation).
func (m *ParticipationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ParticipationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, participation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, participation.FieldUpdatedAt)
	}
	if m.mturkWorkerID != nil {
		fields = append(fields, participation.FieldMturkWorkerID)
	}
	if m.mturkAssignmentID != nil {
		fields = append(fields, participation.FieldMturkAssignmentID)
	}
	if m.mturkHitID != nil {
		fields = append(fields, participation.FieldMturkHitID)
	}
	if m.mturkAcceptedAt != nil {
		fields = append(fields, participation.FieldMturkAcceptedAt)
	}
	if m.mturkSubmittedAt != nil {
		fields = append(fields, participation.FieldMturkSubmittedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ParticipationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case participation.FieldCreatedAt:
		return m.CreatedAt()
	case participation.FieldUpdatedAt:
		return m.UpdatedAt()
	case participation.FieldMturkWorkerID:
		return m.MturkWorkerID()
	case participation.FieldMturkAssignmentID:
		return m.MturkAssignmentID()
	case participation.FieldMturkHitID:
		return m.MturkHitID()
	case participation.FieldMturkAcceptedAt:
		return m.MturkAcceptedAt()
	case participation.FieldMturkSubmittedAt:
		return m.MturkSubmittedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ParticipationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case participation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case participation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case participation.FieldMturkWorkerID:
		return m.OldMturkWorkerID(ctx)
	case participation.FieldMturkAssignmentID:
		return m.OldMturkAssignmentID(ctx)
	case participation.FieldMturkHitID:
		return m.OldMturkHitID(ctx)
	case participation.FieldMturkAcceptedAt:
		return m.OldMturkAcceptedAt(ctx)
	case participation.FieldMturkSubmittedAt:
		return m.OldMturkSubmittedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Participation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ParticipationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case participation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case participation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case participation.FieldMturkWorkerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkWorkerID(v)
		return nil
	case participation.FieldMturkAssignmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkAssignmentID(v)
		return nil
	case participation.FieldMturkHitID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkHitID(v)
		return nil
	case participation.FieldMturkAcceptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkAcceptedAt(v)
		return nil
	case participation.FieldMturkSubmittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkSubmittedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Participation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ParticipationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ParticipationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ParticipationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Participation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ParticipationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ParticipationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParticipationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Participation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ParticipationMutation) ResetField(name string) error {
	switch name {
	case participation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case participation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case participation.FieldMturkWorkerID:
		m.ResetMturkWorkerID()
		return nil
	case participation.FieldMturkAssignmentID:
		m.ResetMturkAssignmentID()
		return nil
	case participation.FieldMturkHitID:
		m.ResetMturkHitID()
		return nil
	case participation.FieldMturkAcceptedAt:
		m.ResetMturkAcceptedAt()
		return nil
	case participation.FieldMturkSubmittedAt:
		m.ResetMturkSubmittedAt()
		return nil
	}
	return fmt.Errorf("unknown Participation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ParticipationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.stepRun != nil {
		edges = append(edges, participation.EdgeStepRun)
	}
	if m.participant != nil {
		edges = append(edges, participation.EdgeParticipant)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ParticipationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case participation.EdgeStepRun:
		if id := m.stepRun; id != nil {
			return []ent.Value{*id}
		}
	case participation.EdgeParticipant:
		if id := m.participant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ParticipationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ParticipationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ParticipationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstepRun {
		edges = append(edges, participation.EdgeStepRun)
	}
	if m.clearedparticipant {
		edges = append(edges, participation.EdgeParticipant)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ParticipationMutation) EdgeCleared(name string) bool {
	switch name {
	case participation.EdgeStepRun:
		return m.clearedstepRun
	case participation.EdgeParticipant:
		return m.clearedparticipant
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ParticipationMutation) ClearEdge(name string) error {
	switch name {
	case participation.EdgeStepRun:
		m.ClearStepRun()
		return nil
	case participation.EdgeParticipant:
		m.ClearParticipant()
		return nil
	}
	return fmt.Errorf("unknown Participation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ParticipationMutation) ResetEdge(name string) error {
	switch name {
	case participation.EdgeStepRun:
		m.ResetStepRun()
		return nil
	case participation.EdgeParticipant:
		m.ResetParticipant()
		return nil
	}
	return fmt.Errorf("unknown Participation edge %s", name)
}

// ProjectMutation represents an operation that mutate the Projects
// nodes in the graph.
type ProjectMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	projectID        *string
	name             *string
	clearedFields    map[string]struct{}
	runs             map[string]struct{}
	removedruns      map[string]struct{}
	clearedruns      bool
	templates        map[string]struct{}
	removedtemplates map[string]struct{}
	clearedtemplates bool
	owner            *string
	clearedowner     bool
	done             bool
	oldValue         func(context.Context) (*Project, error)
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows to manage the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for $n.Name.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the id field of the mutation.
func withProjectID(id string) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Project creation.
func (m *ProjectMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProjectMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the projectID field.
func (m *ProjectMutation) SetProjectID(s string) {
	m.projectID = &s
}

// ProjectID returns the projectID value in the mutation.
func (m *ProjectMutation) ProjectID() (r string, exists bool) {
	v := m.projectID
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old projectID value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldProjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProjectID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID reset all changes of the "projectID" field.
func (m *ProjectMutation) ResetProjectID() {
	m.projectID = nil
}

// SetName sets the name field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// AddRunIDs adds the runs edge to Run by ids.
func (m *ProjectMutation) AddRunIDs(ids ...string) {
	if m.runs == nil {
		m.runs = make(map[string]struct{})
	}
	for i := range ids {
		m.runs[ids[i]] = struct{}{}
	}
}

// ClearRuns clears the runs edge to Run.
func (m *ProjectMutation) ClearRuns() {
	m.clearedruns = true
}

// RunsCleared returns if the edge runs was cleared.
func (m *ProjectMutation) RunsCleared() bool {
	return m.clearedruns
}

// RemoveRunIDs removes the runs edge to Run by ids.
func (m *ProjectMutation) RemoveRunIDs(ids ...string) {
	if m.removedruns == nil {
		m.removedruns = make(map[string]struct{})
	}
	for i := range ids {
		m.removedruns[ids[i]] = struct{}{}
	}
}

// RemovedRuns returns the removed ids of runs.
func (m *ProjectMutation) RemovedRunsIDs() (ids []string) {
	for id := range m.removedruns {
		ids = append(ids, id)
	}
	return
}

// RunsIDs returns the runs ids in the mutation.
func (m *ProjectMutation) RunsIDs() (ids []string) {
	for id := range m.runs {
		ids = append(ids, id)
	}
	return
}

// ResetRuns reset all changes of the "runs" edge.
func (m *ProjectMutation) ResetRuns() {
	m.runs = nil
	m.clearedruns = false
	m.removedruns = nil
}

// AddTemplateIDs adds the templates edge to Template by ids.
func (m *ProjectMutation) AddTemplateIDs(ids ...string) {
	if m.templates == nil {
		m.templates = make(map[string]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the templates edge to Template.
func (m *ProjectMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared returns if the edge templates was cleared.
func (m *ProjectMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the templates edge to Template by ids.
func (m *ProjectMutation) RemoveTemplateIDs(ids ...string) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[string]struct{})
	}
	for i := range ids {
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed ids of templates.
func (m *ProjectMutation) RemovedTemplatesIDs() (ids []string) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the templates ids in the mutation.
func (m *ProjectMutation) TemplatesIDs() (ids []string) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates reset all changes of the "templates" edge.
func (m *ProjectMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// SetOwnerID sets the owner edge to Admin by id.
func (m *ProjectMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Admin.
func (m *ProjectMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *ProjectMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *ProjectMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *ProjectMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.projectID != nil {
		fields = append(fields, project.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldProjectID:
		return m.ProjectID()
	case project.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldProjectID:
		return m.OldProjectID(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldProjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldProjectID:
		m.ResetProjectID()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.runs != nil {
		edges = append(edges, project.EdgeRuns)
	}
	if m.templates != nil {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.owner != nil {
		edges = append(edges, project.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeRuns:
		ids := make([]ent.Value, 0, len(m.runs))
		for id := range m.runs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedruns != nil {
		edges = append(edges, project.EdgeRuns)
	}
	if m.removedtemplates != nil {
		edges = append(edges, project.EdgeTemplates)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeRuns:
		ids := make([]ent.Value, 0, len(m.removedruns))
		for id := range m.removedruns {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedruns {
		edges = append(edges, project.EdgeRuns)
	}
	if m.clearedtemplates {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.clearedowner {
		edges = append(edges, project.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeRuns:
		return m.clearedruns
	case project.EdgeTemplates:
		return m.clearedtemplates
	case project.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeRuns:
		m.ResetRuns()
		return nil
	case project.EdgeTemplates:
		m.ResetTemplates()
		return nil
	case project.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProviderIDMutation represents an operation that mutate the ProviderIDs
// nodes in the graph.
type ProviderIDMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	mturkWorkerID     *string
	clearedFields     map[string]struct{}
	particpant        *string
	clearedparticpant bool
	done              bool
	oldValue          func(context.Context) (*ProviderID, error)
}

var _ ent.Mutation = (*ProviderIDMutation)(nil)

// provideridOption allows to manage the mutation configuration using functional options.
type provideridOption func(*ProviderIDMutation)

// newProviderIDMutation creates new mutation for $n.Name.
func newProviderIDMutation(c config, op Op, opts ...provideridOption) *ProviderIDMutation {
	m := &ProviderIDMutation{
		config:        c,
		op:            op,
		typ:           TypeProviderID,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderIDID sets the id field of the mutation.
func withProviderIDID(id string) provideridOption {
	return func(m *ProviderIDMutation) {
		var (
			err   error
			once  sync.Once
			value *ProviderID
		)
		m.oldValue = func(ctx context.Context) (*ProviderID, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProviderID.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProviderID sets the old ProviderID of the mutation.
func withProviderID(node *ProviderID) provideridOption {
	return func(m *ProviderIDMutation) {
		m.oldValue = func(context.Context) (*ProviderID, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderIDMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderIDMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on ProviderID creation.
func (m *ProviderIDMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProviderIDMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ProviderIDMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ProviderIDMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the ProviderID.
// If the ProviderID object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProviderIDMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ProviderIDMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ProviderIDMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ProviderIDMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the ProviderID.
// If the ProviderID object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProviderIDMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ProviderIDMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMturkWorkerID sets the mturkWorkerID field.
func (m *ProviderIDMutation) SetMturkWorkerID(s string) {
	m.mturkWorkerID = &s
}

// MturkWorkerID returns the mturkWorkerID value in the mutation.
func (m *ProviderIDMutation) MturkWorkerID() (r string, exists bool) {
	v := m.mturkWorkerID
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkWorkerID returns the old mturkWorkerID value of the ProviderID.
// If the ProviderID object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProviderIDMutation) OldMturkWorkerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkWorkerID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkWorkerID: %w", err)
	}
	return oldValue.MturkWorkerID, nil
}

// ResetMturkWorkerID reset all changes of the "mturkWorkerID" field.
func (m *ProviderIDMutation) ResetMturkWorkerID() {
	m.mturkWorkerID = nil
}

// SetParticpantID sets the particpant edge to Participant by id.
func (m *ProviderIDMutation) SetParticpantID(id string) {
	m.particpant = &id
}

// ClearParticpant clears the particpant edge to Participant.
func (m *ProviderIDMutation) ClearParticpant() {
	m.clearedparticpant = true
}

// ParticpantCleared returns if the edge particpant was cleared.
func (m *ProviderIDMutation) ParticpantCleared() bool {
	return m.clearedparticpant
}

// ParticpantID returns the particpant id in the mutation.
func (m *ProviderIDMutation) ParticpantID() (id string, exists bool) {
	if m.particpant != nil {
		return *m.particpant, true
	}
	return
}

// ParticpantIDs returns the particpant ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParticpantID instead. It exists only for internal usage by the builders.
func (m *ProviderIDMutation) ParticpantIDs() (ids []string) {
	if id := m.particpant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParticpant reset all changes of the "particpant" edge.
func (m *ProviderIDMutation) ResetParticpant() {
	m.particpant = nil
	m.clearedparticpant = false
}

// Op returns the operation name.
func (m *ProviderIDMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProviderID).
func (m *ProviderIDMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProviderIDMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, providerid.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, providerid.FieldUpdatedAt)
	}
	if m.mturkWorkerID != nil {
		fields = append(fields, providerid.FieldMturkWorkerID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProviderIDMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case providerid.FieldCreatedAt:
		return m.CreatedAt()
	case providerid.FieldUpdatedAt:
		return m.UpdatedAt()
	case providerid.FieldMturkWorkerID:
		return m.MturkWorkerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProviderIDMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case providerid.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case providerid.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case providerid.FieldMturkWorkerID:
		return m.OldMturkWorkerID(ctx)
	}
	return nil, fmt.Errorf("unknown ProviderID field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProviderIDMutation) SetField(name string, value ent.Value) error {
	switch name {
	case providerid.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case providerid.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case providerid.FieldMturkWorkerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkWorkerID(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderID field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProviderIDMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProviderIDMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProviderIDMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProviderID numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProviderIDMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProviderIDMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderIDMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProviderID nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProviderIDMutation) ResetField(name string) error {
	switch name {
	case providerid.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case providerid.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case providerid.FieldMturkWorkerID:
		m.ResetMturkWorkerID()
		return nil
	}
	return fmt.Errorf("unknown ProviderID field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProviderIDMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.particpant != nil {
		edges = append(edges, providerid.EdgeParticpant)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProviderIDMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case providerid.EdgeParticpant:
		if id := m.particpant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProviderIDMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProviderIDMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProviderIDMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparticpant {
		edges = append(edges, providerid.EdgeParticpant)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProviderIDMutation) EdgeCleared(name string) bool {
	switch name {
	case providerid.EdgeParticpant:
		return m.clearedparticpant
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProviderIDMutation) ClearEdge(name string) error {
	switch name {
	case providerid.EdgeParticpant:
		m.ClearParticpant()
		return nil
	}
	return fmt.Errorf("unknown ProviderID unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProviderIDMutation) ResetEdge(name string) error {
	switch name {
	case providerid.EdgeParticpant:
		m.ResetParticpant()
		return nil
	}
	return fmt.Errorf("unknown ProviderID edge %s", name)
}

// RunMutation represents an operation that mutate the Runs
// nodes in the graph.
type RunMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	status             *run.Status
	startedAt          *time.Time
	endedAt            *time.Time
	name               *string
	startAt            *time.Time
	error              *string
	clearedFields      map[string]struct{}
	project            *string
	clearedproject     bool
	template           *string
	clearedtemplate    bool
	currentStep        *string
	clearedcurrentStep bool
	steps              map[string]struct{}
	removedsteps       map[string]struct{}
	clearedsteps       bool
	done               bool
	oldValue           func(context.Context) (*Run, error)
}

var _ ent.Mutation = (*RunMutation)(nil)

// runOption allows to manage the mutation configuration using functional options.
type runOption func(*RunMutation)

// newRunMutation creates new mutation for $n.Name.
func newRunMutation(c config, op Op, opts ...runOption) *RunMutation {
	m := &RunMutation{
		config:        c,
		op:            op,
		typ:           TypeRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunID sets the id field of the mutation.
func withRunID(id string) runOption {
	return func(m *RunMutation) {
		var (
			err   error
			once  sync.Once
			value *Run
		)
		m.oldValue = func(ctx context.Context) (*Run, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Run.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRun sets the old Run of the mutation.
func withRun(node *Run) runOption {
	return func(m *RunMutation) {
		m.oldValue = func(context.Context) (*Run, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Run creation.
func (m *RunMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RunMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *RunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *RunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *RunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *RunMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *RunMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *RunMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the status field.
func (m *RunMutation) SetStatus(r run.Status) {
	m.status = &r
}

// Status returns the status value in the mutation.
func (m *RunMutation) Status() (r run.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldStatus(ctx context.Context) (v run.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *RunMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the startedAt field.
func (m *RunMutation) SetStartedAt(t time.Time) {
	m.startedAt = &t
}

// StartedAt returns the startedAt value in the mutation.
func (m *RunMutation) StartedAt() (r time.Time, exists bool) {
	v := m.startedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old startedAt value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of startedAt.
func (m *RunMutation) ClearStartedAt() {
	m.startedAt = nil
	m.clearedFields[run.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the field startedAt was cleared in this mutation.
func (m *RunMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[run.FieldStartedAt]
	return ok
}

// ResetStartedAt reset all changes of the "startedAt" field.
func (m *RunMutation) ResetStartedAt() {
	m.startedAt = nil
	delete(m.clearedFields, run.FieldStartedAt)
}

// SetEndedAt sets the endedAt field.
func (m *RunMutation) SetEndedAt(t time.Time) {
	m.endedAt = &t
}

// EndedAt returns the endedAt value in the mutation.
func (m *RunMutation) EndedAt() (r time.Time, exists bool) {
	v := m.endedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old endedAt value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of endedAt.
func (m *RunMutation) ClearEndedAt() {
	m.endedAt = nil
	m.clearedFields[run.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the field endedAt was cleared in this mutation.
func (m *RunMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[run.FieldEndedAt]
	return ok
}

// ResetEndedAt reset all changes of the "endedAt" field.
func (m *RunMutation) ResetEndedAt() {
	m.endedAt = nil
	delete(m.clearedFields, run.FieldEndedAt)
}

// SetName sets the name field.
func (m *RunMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RunMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RunMutation) ResetName() {
	m.name = nil
}

// SetStartAt sets the startAt field.
func (m *RunMutation) SetStartAt(t time.Time) {
	m.startAt = &t
}

// StartAt returns the startAt value in the mutation.
func (m *RunMutation) StartAt() (r time.Time, exists bool) {
	v := m.startAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old startAt value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of startAt.
func (m *RunMutation) ClearStartAt() {
	m.startAt = nil
	m.clearedFields[run.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the field startAt was cleared in this mutation.
func (m *RunMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[run.FieldStartAt]
	return ok
}

// ResetStartAt reset all changes of the "startAt" field.
func (m *RunMutation) ResetStartAt() {
	m.startAt = nil
	delete(m.clearedFields, run.FieldStartAt)
}

// SetError sets the error field.
func (m *RunMutation) SetError(s string) {
	m.error = &s
}

// Error returns the error value in the mutation.
func (m *RunMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old error value of the Run.
// If the Run object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RunMutation) OldError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldError is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of error.
func (m *RunMutation) ClearError() {
	m.error = nil
	m.clearedFields[run.FieldError] = struct{}{}
}

// ErrorCleared returns if the field error was cleared in this mutation.
func (m *RunMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[run.FieldError]
	return ok
}

// ResetError reset all changes of the "error" field.
func (m *RunMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, run.FieldError)
}

// SetProjectID sets the project edge to Project by id.
func (m *RunMutation) SetProjectID(id string) {
	m.project = &id
}

// ClearProject clears the project edge to Project.
func (m *RunMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared returns if the edge project was cleared.
func (m *RunMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the project id in the mutation.
func (m *RunMutation) ProjectID() (id string, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the project ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RunMutation) ProjectIDs() (ids []string) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject reset all changes of the "project" edge.
func (m *RunMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetTemplateID sets the template edge to Template by id.
func (m *RunMutation) SetTemplateID(id string) {
	m.template = &id
}

// ClearTemplate clears the template edge to Template.
func (m *RunMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared returns if the edge template was cleared.
func (m *RunMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateID returns the template id in the mutation.
func (m *RunMutation) TemplateID() (id string, exists bool) {
	if m.template != nil {
		return *m.template, true
	}
	return
}

// TemplateIDs returns the template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *RunMutation) TemplateIDs() (ids []string) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate reset all changes of the "template" edge.
func (m *RunMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// SetCurrentStepID sets the currentStep edge to StepRun by id.
func (m *RunMutation) SetCurrentStepID(id string) {
	m.currentStep = &id
}

// ClearCurrentStep clears the currentStep edge to StepRun.
func (m *RunMutation) ClearCurrentStep() {
	m.clearedcurrentStep = true
}

// CurrentStepCleared returns if the edge currentStep was cleared.
func (m *RunMutation) CurrentStepCleared() bool {
	return m.clearedcurrentStep
}

// CurrentStepID returns the currentStep id in the mutation.
func (m *RunMutation) CurrentStepID() (id string, exists bool) {
	if m.currentStep != nil {
		return *m.currentStep, true
	}
	return
}

// CurrentStepIDs returns the currentStep ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CurrentStepID instead. It exists only for internal usage by the builders.
func (m *RunMutation) CurrentStepIDs() (ids []string) {
	if id := m.currentStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrentStep reset all changes of the "currentStep" edge.
func (m *RunMutation) ResetCurrentStep() {
	m.currentStep = nil
	m.clearedcurrentStep = false
}

// AddStepIDs adds the steps edge to StepRun by ids.
func (m *RunMutation) AddStepIDs(ids ...string) {
	if m.steps == nil {
		m.steps = make(map[string]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the steps edge to StepRun.
func (m *RunMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared returns if the edge steps was cleared.
func (m *RunMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the steps edge to StepRun by ids.
func (m *RunMutation) RemoveStepIDs(ids ...string) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[string]struct{})
	}
	for i := range ids {
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed ids of steps.
func (m *RunMutation) RemovedStepsIDs() (ids []string) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the steps ids in the mutation.
func (m *RunMutation) StepsIDs() (ids []string) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps reset all changes of the "steps" edge.
func (m *RunMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// Op returns the operation name.
func (m *RunMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Run).
func (m *RunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RunMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, run.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, run.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, run.FieldStatus)
	}
	if m.startedAt != nil {
		fields = append(fields, run.FieldStartedAt)
	}
	if m.endedAt != nil {
		fields = append(fields, run.FieldEndedAt)
	}
	if m.name != nil {
		fields = append(fields, run.FieldName)
	}
	if m.startAt != nil {
		fields = append(fields, run.FieldStartAt)
	}
	if m.error != nil {
		fields = append(fields, run.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case run.FieldCreatedAt:
		return m.CreatedAt()
	case run.FieldUpdatedAt:
		return m.UpdatedAt()
	case run.FieldStatus:
		return m.Status()
	case run.FieldStartedAt:
		return m.StartedAt()
	case run.FieldEndedAt:
		return m.EndedAt()
	case run.FieldName:
		return m.Name()
	case run.FieldStartAt:
		return m.StartAt()
	case run.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case run.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case run.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case run.FieldStatus:
		return m.OldStatus(ctx)
	case run.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case run.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case run.FieldName:
		return m.OldName(ctx)
	case run.FieldStartAt:
		return m.OldStartAt(ctx)
	case run.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Run field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case run.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case run.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case run.FieldStatus:
		v, ok := value.(run.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case run.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case run.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case run.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case run.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case run.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Run numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RunMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(run.FieldStartedAt) {
		fields = append(fields, run.FieldStartedAt)
	}
	if m.FieldCleared(run.FieldEndedAt) {
		fields = append(fields, run.FieldEndedAt)
	}
	if m.FieldCleared(run.FieldStartAt) {
		fields = append(fields, run.FieldStartAt)
	}
	if m.FieldCleared(run.FieldError) {
		fields = append(fields, run.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunMutation) ClearField(name string) error {
	switch name {
	case run.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case run.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	case run.FieldStartAt:
		m.ClearStartAt()
		return nil
	case run.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Run nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RunMutation) ResetField(name string) error {
	switch name {
	case run.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case run.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case run.FieldStatus:
		m.ResetStatus()
		return nil
	case run.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case run.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case run.FieldName:
		m.ResetName()
		return nil
	case run.FieldStartAt:
		m.ResetStartAt()
		return nil
	case run.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RunMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, run.EdgeProject)
	}
	if m.template != nil {
		edges = append(edges, run.EdgeTemplate)
	}
	if m.currentStep != nil {
		edges = append(edges, run.EdgeCurrentStep)
	}
	if m.steps != nil {
		edges = append(edges, run.EdgeSteps)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case run.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case run.EdgeCurrentStep:
		if id := m.currentStep; id != nil {
			return []ent.Value{*id}
		}
	case run.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsteps != nil {
		edges = append(edges, run.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, run.EdgeProject)
	}
	if m.clearedtemplate {
		edges = append(edges, run.EdgeTemplate)
	}
	if m.clearedcurrentStep {
		edges = append(edges, run.EdgeCurrentStep)
	}
	if m.clearedsteps {
		edges = append(edges, run.EdgeSteps)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RunMutation) EdgeCleared(name string) bool {
	switch name {
	case run.EdgeProject:
		return m.clearedproject
	case run.EdgeTemplate:
		return m.clearedtemplate
	case run.EdgeCurrentStep:
		return m.clearedcurrentStep
	case run.EdgeSteps:
		return m.clearedsteps
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RunMutation) ClearEdge(name string) error {
	switch name {
	case run.EdgeProject:
		m.ClearProject()
		return nil
	case run.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case run.EdgeCurrentStep:
		m.ClearCurrentStep()
		return nil
	}
	return fmt.Errorf("unknown Run unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RunMutation) ResetEdge(name string) error {
	switch name {
	case run.EdgeProject:
		m.ResetProject()
		return nil
	case run.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case run.EdgeCurrentStep:
		m.ResetCurrentStep()
		return nil
	case run.EdgeSteps:
		m.ResetSteps()
		return nil
	}
	return fmt.Errorf("unknown Run edge %s", name)
}

// StepMutation represents an operation that mutate the Steps
// nodes in the graph.
type StepMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	_type           *step.Type
	index           *int
	addindex        *int
	duration        *int
	addduration     *int
	msgArgs         *[]byte
	hitArgs         *[]byte
	filterArgs      *[]byte
	clearedFields   map[string]struct{}
	stepRun         *string
	clearedstepRun  bool
	template        *string
	clearedtemplate bool
	done            bool
	oldValue        func(context.Context) (*Step, error)
}

var _ ent.Mutation = (*StepMutation)(nil)

// stepOption allows to manage the mutation configuration using functional options.
type stepOption func(*StepMutation)

// newStepMutation creates new mutation for $n.Name.
func newStepMutation(c config, op Op, opts ...stepOption) *StepMutation {
	m := &StepMutation{
		config:        c,
		op:            op,
		typ:           TypeStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStepID sets the id field of the mutation.
func withStepID(id string) stepOption {
	return func(m *StepMutation) {
		var (
			err   error
			once  sync.Once
			value *Step
		)
		m.oldValue = func(ctx context.Context) (*Step, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Step.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStep sets the old Step of the mutation.
func withStep(node *Step) stepOption {
	return func(m *StepMutation) {
		m.oldValue = func(context.Context) (*Step, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Step creation.
func (m *StepMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StepMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *StepMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *StepMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *StepMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *StepMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *StepMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *StepMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the type field.
func (m *StepMutation) SetType(s step.Type) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *StepMutation) GetType() (r step.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldType(ctx context.Context) (v step.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *StepMutation) ResetType() {
	m._type = nil
}

// SetIndex sets the index field.
func (m *StepMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *StepMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *StepMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *StepMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *StepMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetDuration sets the duration field.
func (m *StepMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *StepMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to duration.
func (m *StepMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *StepMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration reset all changes of the "duration" field.
func (m *StepMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetMsgArgs sets the msgArgs field.
func (m *StepMutation) SetMsgArgs(b []byte) {
	m.msgArgs = &b
}

// MsgArgs returns the msgArgs value in the mutation.
func (m *StepMutation) MsgArgs() (r []byte, exists bool) {
	v := m.msgArgs
	if v == nil {
		return
	}
	return *v, true
}

// OldMsgArgs returns the old msgArgs value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldMsgArgs(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMsgArgs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMsgArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsgArgs: %w", err)
	}
	return oldValue.MsgArgs, nil
}

// ClearMsgArgs clears the value of msgArgs.
func (m *StepMutation) ClearMsgArgs() {
	m.msgArgs = nil
	m.clearedFields[step.FieldMsgArgs] = struct{}{}
}

// MsgArgsCleared returns if the field msgArgs was cleared in this mutation.
func (m *StepMutation) MsgArgsCleared() bool {
	_, ok := m.clearedFields[step.FieldMsgArgs]
	return ok
}

// ResetMsgArgs reset all changes of the "msgArgs" field.
func (m *StepMutation) ResetMsgArgs() {
	m.msgArgs = nil
	delete(m.clearedFields, step.FieldMsgArgs)
}

// SetHitArgs sets the hitArgs field.
func (m *StepMutation) SetHitArgs(b []byte) {
	m.hitArgs = &b
}

// HitArgs returns the hitArgs value in the mutation.
func (m *StepMutation) HitArgs() (r []byte, exists bool) {
	v := m.hitArgs
	if v == nil {
		return
	}
	return *v, true
}

// OldHitArgs returns the old hitArgs value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldHitArgs(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHitArgs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHitArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHitArgs: %w", err)
	}
	return oldValue.HitArgs, nil
}

// ClearHitArgs clears the value of hitArgs.
func (m *StepMutation) ClearHitArgs() {
	m.hitArgs = nil
	m.clearedFields[step.FieldHitArgs] = struct{}{}
}

// HitArgsCleared returns if the field hitArgs was cleared in this mutation.
func (m *StepMutation) HitArgsCleared() bool {
	_, ok := m.clearedFields[step.FieldHitArgs]
	return ok
}

// ResetHitArgs reset all changes of the "hitArgs" field.
func (m *StepMutation) ResetHitArgs() {
	m.hitArgs = nil
	delete(m.clearedFields, step.FieldHitArgs)
}

// SetFilterArgs sets the filterArgs field.
func (m *StepMutation) SetFilterArgs(b []byte) {
	m.filterArgs = &b
}

// FilterArgs returns the filterArgs value in the mutation.
func (m *StepMutation) FilterArgs() (r []byte, exists bool) {
	v := m.filterArgs
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterArgs returns the old filterArgs value of the Step.
// If the Step object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepMutation) OldFilterArgs(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFilterArgs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFilterArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterArgs: %w", err)
	}
	return oldValue.FilterArgs, nil
}

// ClearFilterArgs clears the value of filterArgs.
func (m *StepMutation) ClearFilterArgs() {
	m.filterArgs = nil
	m.clearedFields[step.FieldFilterArgs] = struct{}{}
}

// FilterArgsCleared returns if the field filterArgs was cleared in this mutation.
func (m *StepMutation) FilterArgsCleared() bool {
	_, ok := m.clearedFields[step.FieldFilterArgs]
	return ok
}

// ResetFilterArgs reset all changes of the "filterArgs" field.
func (m *StepMutation) ResetFilterArgs() {
	m.filterArgs = nil
	delete(m.clearedFields, step.FieldFilterArgs)
}

// SetStepRunID sets the stepRun edge to StepRun by id.
func (m *StepMutation) SetStepRunID(id string) {
	m.stepRun = &id
}

// ClearStepRun clears the stepRun edge to StepRun.
func (m *StepMutation) ClearStepRun() {
	m.clearedstepRun = true
}

// StepRunCleared returns if the edge stepRun was cleared.
func (m *StepMutation) StepRunCleared() bool {
	return m.clearedstepRun
}

// StepRunID returns the stepRun id in the mutation.
func (m *StepMutation) StepRunID() (id string, exists bool) {
	if m.stepRun != nil {
		return *m.stepRun, true
	}
	return
}

// StepRunIDs returns the stepRun ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StepRunID instead. It exists only for internal usage by the builders.
func (m *StepMutation) StepRunIDs() (ids []string) {
	if id := m.stepRun; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStepRun reset all changes of the "stepRun" edge.
func (m *StepMutation) ResetStepRun() {
	m.stepRun = nil
	m.clearedstepRun = false
}

// SetTemplateID sets the template edge to Template by id.
func (m *StepMutation) SetTemplateID(id string) {
	m.template = &id
}

// ClearTemplate clears the template edge to Template.
func (m *StepMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared returns if the edge template was cleared.
func (m *StepMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateID returns the template id in the mutation.
func (m *StepMutation) TemplateID() (id string, exists bool) {
	if m.template != nil {
		return *m.template, true
	}
	return
}

// TemplateIDs returns the template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *StepMutation) TemplateIDs() (ids []string) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate reset all changes of the "template" edge.
func (m *StepMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// Op returns the operation name.
func (m *StepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Step).
func (m *StepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StepMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, step.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, step.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, step.FieldType)
	}
	if m.index != nil {
		fields = append(fields, step.FieldIndex)
	}
	if m.duration != nil {
		fields = append(fields, step.FieldDuration)
	}
	if m.msgArgs != nil {
		fields = append(fields, step.FieldMsgArgs)
	}
	if m.hitArgs != nil {
		fields = append(fields, step.FieldHitArgs)
	}
	if m.filterArgs != nil {
		fields = append(fields, step.FieldFilterArgs)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case step.FieldCreatedAt:
		return m.CreatedAt()
	case step.FieldUpdatedAt:
		return m.UpdatedAt()
	case step.FieldType:
		return m.GetType()
	case step.FieldIndex:
		return m.Index()
	case step.FieldDuration:
		return m.Duration()
	case step.FieldMsgArgs:
		return m.MsgArgs()
	case step.FieldHitArgs:
		return m.HitArgs()
	case step.FieldFilterArgs:
		return m.FilterArgs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case step.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case step.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case step.FieldType:
		return m.OldType(ctx)
	case step.FieldIndex:
		return m.OldIndex(ctx)
	case step.FieldDuration:
		return m.OldDuration(ctx)
	case step.FieldMsgArgs:
		return m.OldMsgArgs(ctx)
	case step.FieldHitArgs:
		return m.OldHitArgs(ctx)
	case step.FieldFilterArgs:
		return m.OldFilterArgs(ctx)
	}
	return nil, fmt.Errorf("unknown Step field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case step.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case step.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case step.FieldType:
		v, ok := value.(step.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case step.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case step.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case step.FieldMsgArgs:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsgArgs(v)
		return nil
	case step.FieldHitArgs:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHitArgs(v)
		return nil
	case step.FieldFilterArgs:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterArgs(v)
		return nil
	}
	return fmt.Errorf("unknown Step field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StepMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, step.FieldIndex)
	}
	if m.addduration != nil {
		fields = append(fields, step.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case step.FieldIndex:
		return m.AddedIndex()
	case step.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case step.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case step.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Step numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(step.FieldMsgArgs) {
		fields = append(fields, step.FieldMsgArgs)
	}
	if m.FieldCleared(step.FieldHitArgs) {
		fields = append(fields, step.FieldHitArgs)
	}
	if m.FieldCleared(step.FieldFilterArgs) {
		fields = append(fields, step.FieldFilterArgs)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StepMutation) ClearField(name string) error {
	switch name {
	case step.FieldMsgArgs:
		m.ClearMsgArgs()
		return nil
	case step.FieldHitArgs:
		m.ClearHitArgs()
		return nil
	case step.FieldFilterArgs:
		m.ClearFilterArgs()
		return nil
	}
	return fmt.Errorf("unknown Step nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StepMutation) ResetField(name string) error {
	switch name {
	case step.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case step.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case step.FieldType:
		m.ResetType()
		return nil
	case step.FieldIndex:
		m.ResetIndex()
		return nil
	case step.FieldDuration:
		m.ResetDuration()
		return nil
	case step.FieldMsgArgs:
		m.ResetMsgArgs()
		return nil
	case step.FieldHitArgs:
		m.ResetHitArgs()
		return nil
	case step.FieldFilterArgs:
		m.ResetFilterArgs()
		return nil
	}
	return fmt.Errorf("unknown Step field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StepMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.stepRun != nil {
		edges = append(edges, step.EdgeStepRun)
	}
	if m.template != nil {
		edges = append(edges, step.EdgeTemplate)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case step.EdgeStepRun:
		if id := m.stepRun; id != nil {
			return []ent.Value{*id}
		}
	case step.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstepRun {
		edges = append(edges, step.EdgeStepRun)
	}
	if m.clearedtemplate {
		edges = append(edges, step.EdgeTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StepMutation) EdgeCleared(name string) bool {
	switch name {
	case step.EdgeStepRun:
		return m.clearedstepRun
	case step.EdgeTemplate:
		return m.clearedtemplate
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StepMutation) ClearEdge(name string) error {
	switch name {
	case step.EdgeStepRun:
		m.ClearStepRun()
		return nil
	case step.EdgeTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown Step unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StepMutation) ResetEdge(name string) error {
	switch name {
	case step.EdgeStepRun:
		m.ResetStepRun()
		return nil
	case step.EdgeTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown Step edge %s", name)
}

// StepRunMutation represents an operation that mutate the StepRuns
// nodes in the graph.
type StepRunMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	created_at                 *time.Time
	updated_at                 *time.Time
	status                     *steprun.Status
	startedAt                  *time.Time
	endedAt                    *time.Time
	index                      *int
	addindex                   *int
	participantsCount          *int
	addparticipantsCount       *int
	hitID                      *string
	urlToken                   *string
	clearedFields              map[string]struct{}
	createdParticipants        map[string]struct{}
	removedcreatedParticipants map[string]struct{}
	clearedcreatedParticipants bool
	participants               map[string]struct{}
	removedparticipants        map[string]struct{}
	clearedparticipants        bool
	participations             map[string]struct{}
	removedparticipations      map[string]struct{}
	clearedparticipations      bool
	step                       *string
	clearedstep                bool
	run                        *string
	clearedrun                 bool
	done                       bool
	oldValue                   func(context.Context) (*StepRun, error)
}

var _ ent.Mutation = (*StepRunMutation)(nil)

// steprunOption allows to manage the mutation configuration using functional options.
type steprunOption func(*StepRunMutation)

// newStepRunMutation creates new mutation for $n.Name.
func newStepRunMutation(c config, op Op, opts ...steprunOption) *StepRunMutation {
	m := &StepRunMutation{
		config:        c,
		op:            op,
		typ:           TypeStepRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStepRunID sets the id field of the mutation.
func withStepRunID(id string) steprunOption {
	return func(m *StepRunMutation) {
		var (
			err   error
			once  sync.Once
			value *StepRun
		)
		m.oldValue = func(ctx context.Context) (*StepRun, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StepRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStepRun sets the old StepRun of the mutation.
func withStepRun(node *StepRun) steprunOption {
	return func(m *StepRunMutation) {
		m.oldValue = func(context.Context) (*StepRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StepRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StepRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on StepRun creation.
func (m *StepRunMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StepRunMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *StepRunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *StepRunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *StepRunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *StepRunMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *StepRunMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *StepRunMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the status field.
func (m *StepRunMutation) SetStatus(s steprun.Status) {
	m.status = &s
}

// Status returns the status value in the mutation.
func (m *StepRunMutation) Status() (r steprun.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldStatus(ctx context.Context) (v steprun.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *StepRunMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the startedAt field.
func (m *StepRunMutation) SetStartedAt(t time.Time) {
	m.startedAt = &t
}

// StartedAt returns the startedAt value in the mutation.
func (m *StepRunMutation) StartedAt() (r time.Time, exists bool) {
	v := m.startedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old startedAt value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of startedAt.
func (m *StepRunMutation) ClearStartedAt() {
	m.startedAt = nil
	m.clearedFields[steprun.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the field startedAt was cleared in this mutation.
func (m *StepRunMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[steprun.FieldStartedAt]
	return ok
}

// ResetStartedAt reset all changes of the "startedAt" field.
func (m *StepRunMutation) ResetStartedAt() {
	m.startedAt = nil
	delete(m.clearedFields, steprun.FieldStartedAt)
}

// SetEndedAt sets the endedAt field.
func (m *StepRunMutation) SetEndedAt(t time.Time) {
	m.endedAt = &t
}

// EndedAt returns the endedAt value in the mutation.
func (m *StepRunMutation) EndedAt() (r time.Time, exists bool) {
	v := m.endedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old endedAt value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of endedAt.
func (m *StepRunMutation) ClearEndedAt() {
	m.endedAt = nil
	m.clearedFields[steprun.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the field endedAt was cleared in this mutation.
func (m *StepRunMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[steprun.FieldEndedAt]
	return ok
}

// ResetEndedAt reset all changes of the "endedAt" field.
func (m *StepRunMutation) ResetEndedAt() {
	m.endedAt = nil
	delete(m.clearedFields, steprun.FieldEndedAt)
}

// SetIndex sets the index field.
func (m *StepRunMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *StepRunMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *StepRunMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *StepRunMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *StepRunMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetParticipantsCount sets the participantsCount field.
func (m *StepRunMutation) SetParticipantsCount(i int) {
	m.participantsCount = &i
	m.addparticipantsCount = nil
}

// ParticipantsCount returns the participantsCount value in the mutation.
func (m *StepRunMutation) ParticipantsCount() (r int, exists bool) {
	v := m.participantsCount
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantsCount returns the old participantsCount value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldParticipantsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParticipantsCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParticipantsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantsCount: %w", err)
	}
	return oldValue.ParticipantsCount, nil
}

// AddParticipantsCount adds i to participantsCount.
func (m *StepRunMutation) AddParticipantsCount(i int) {
	if m.addparticipantsCount != nil {
		*m.addparticipantsCount += i
	} else {
		m.addparticipantsCount = &i
	}
}

// AddedParticipantsCount returns the value that was added to the participantsCount field in this mutation.
func (m *StepRunMutation) AddedParticipantsCount() (r int, exists bool) {
	v := m.addparticipantsCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetParticipantsCount reset all changes of the "participantsCount" field.
func (m *StepRunMutation) ResetParticipantsCount() {
	m.participantsCount = nil
	m.addparticipantsCount = nil
}

// SetHitID sets the hitID field.
func (m *StepRunMutation) SetHitID(s string) {
	m.hitID = &s
}

// HitID returns the hitID value in the mutation.
func (m *StepRunMutation) HitID() (r string, exists bool) {
	v := m.hitID
	if v == nil {
		return
	}
	return *v, true
}

// OldHitID returns the old hitID value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldHitID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHitID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHitID: %w", err)
	}
	return oldValue.HitID, nil
}

// ClearHitID clears the value of hitID.
func (m *StepRunMutation) ClearHitID() {
	m.hitID = nil
	m.clearedFields[steprun.FieldHitID] = struct{}{}
}

// HitIDCleared returns if the field hitID was cleared in this mutation.
func (m *StepRunMutation) HitIDCleared() bool {
	_, ok := m.clearedFields[steprun.FieldHitID]
	return ok
}

// ResetHitID reset all changes of the "hitID" field.
func (m *StepRunMutation) ResetHitID() {
	m.hitID = nil
	delete(m.clearedFields, steprun.FieldHitID)
}

// SetUrlToken sets the urlToken field.
func (m *StepRunMutation) SetUrlToken(s string) {
	m.urlToken = &s
}

// UrlToken returns the urlToken value in the mutation.
func (m *StepRunMutation) UrlToken() (r string, exists bool) {
	v := m.urlToken
	if v == nil {
		return
	}
	return *v, true
}

// OldUrlToken returns the old urlToken value of the StepRun.
// If the StepRun object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StepRunMutation) OldUrlToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUrlToken is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUrlToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrlToken: %w", err)
	}
	return oldValue.UrlToken, nil
}

// ResetUrlToken reset all changes of the "urlToken" field.
func (m *StepRunMutation) ResetUrlToken() {
	m.urlToken = nil
}

// AddCreatedParticipantIDs adds the createdParticipants edge to Participant by ids.
func (m *StepRunMutation) AddCreatedParticipantIDs(ids ...string) {
	if m.createdParticipants == nil {
		m.createdParticipants = make(map[string]struct{})
	}
	for i := range ids {
		m.createdParticipants[ids[i]] = struct{}{}
	}
}

// ClearCreatedParticipants clears the createdParticipants edge to Participant.
func (m *StepRunMutation) ClearCreatedParticipants() {
	m.clearedcreatedParticipants = true
}

// CreatedParticipantsCleared returns if the edge createdParticipants was cleared.
func (m *StepRunMutation) CreatedParticipantsCleared() bool {
	return m.clearedcreatedParticipants
}

// RemoveCreatedParticipantIDs removes the createdParticipants edge to Participant by ids.
func (m *StepRunMutation) RemoveCreatedParticipantIDs(ids ...string) {
	if m.removedcreatedParticipants == nil {
		m.removedcreatedParticipants = make(map[string]struct{})
	}
	for i := range ids {
		m.removedcreatedParticipants[ids[i]] = struct{}{}
	}
}

// RemovedCreatedParticipants returns the removed ids of createdParticipants.
func (m *StepRunMutation) RemovedCreatedParticipantsIDs() (ids []string) {
	for id := range m.removedcreatedParticipants {
		ids = append(ids, id)
	}
	return
}

// CreatedParticipantsIDs returns the createdParticipants ids in the mutation.
func (m *StepRunMutation) CreatedParticipantsIDs() (ids []string) {
	for id := range m.createdParticipants {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedParticipants reset all changes of the "createdParticipants" edge.
func (m *StepRunMutation) ResetCreatedParticipants() {
	m.createdParticipants = nil
	m.clearedcreatedParticipants = false
	m.removedcreatedParticipants = nil
}

// AddParticipantIDs adds the participants edge to Participant by ids.
func (m *StepRunMutation) AddParticipantIDs(ids ...string) {
	if m.participants == nil {
		m.participants = make(map[string]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the participants edge to Participant.
func (m *StepRunMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared returns if the edge participants was cleared.
func (m *StepRunMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the participants edge to Participant by ids.
func (m *StepRunMutation) RemoveParticipantIDs(ids ...string) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[string]struct{})
	}
	for i := range ids {
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed ids of participants.
func (m *StepRunMutation) RemovedParticipantsIDs() (ids []string) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the participants ids in the mutation.
func (m *StepRunMutation) ParticipantsIDs() (ids []string) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants reset all changes of the "participants" edge.
func (m *StepRunMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// AddParticipationIDs adds the participations edge to Participation by ids.
func (m *StepRunMutation) AddParticipationIDs(ids ...string) {
	if m.participations == nil {
		m.participations = make(map[string]struct{})
	}
	for i := range ids {
		m.participations[ids[i]] = struct{}{}
	}
}

// ClearParticipations clears the participations edge to Participation.
func (m *StepRunMutation) ClearParticipations() {
	m.clearedparticipations = true
}

// ParticipationsCleared returns if the edge participations was cleared.
func (m *StepRunMutation) ParticipationsCleared() bool {
	return m.clearedparticipations
}

// RemoveParticipationIDs removes the participations edge to Participation by ids.
func (m *StepRunMutation) RemoveParticipationIDs(ids ...string) {
	if m.removedparticipations == nil {
		m.removedparticipations = make(map[string]struct{})
	}
	for i := range ids {
		m.removedparticipations[ids[i]] = struct{}{}
	}
}

// RemovedParticipations returns the removed ids of participations.
func (m *StepRunMutation) RemovedParticipationsIDs() (ids []string) {
	for id := range m.removedparticipations {
		ids = append(ids, id)
	}
	return
}

// ParticipationsIDs returns the participations ids in the mutation.
func (m *StepRunMutation) ParticipationsIDs() (ids []string) {
	for id := range m.participations {
		ids = append(ids, id)
	}
	return
}

// ResetParticipations reset all changes of the "participations" edge.
func (m *StepRunMutation) ResetParticipations() {
	m.participations = nil
	m.clearedparticipations = false
	m.removedparticipations = nil
}

// SetStepID sets the step edge to Step by id.
func (m *StepRunMutation) SetStepID(id string) {
	m.step = &id
}

// ClearStep clears the step edge to Step.
func (m *StepRunMutation) ClearStep() {
	m.clearedstep = true
}

// StepCleared returns if the edge step was cleared.
func (m *StepRunMutation) StepCleared() bool {
	return m.clearedstep
}

// StepID returns the step id in the mutation.
func (m *StepRunMutation) StepID() (id string, exists bool) {
	if m.step != nil {
		return *m.step, true
	}
	return
}

// StepIDs returns the step ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StepID instead. It exists only for internal usage by the builders.
func (m *StepRunMutation) StepIDs() (ids []string) {
	if id := m.step; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStep reset all changes of the "step" edge.
func (m *StepRunMutation) ResetStep() {
	m.step = nil
	m.clearedstep = false
}

// SetRunID sets the run edge to Run by id.
func (m *StepRunMutation) SetRunID(id string) {
	m.run = &id
}

// ClearRun clears the run edge to Run.
func (m *StepRunMutation) ClearRun() {
	m.clearedrun = true
}

// RunCleared returns if the edge run was cleared.
func (m *StepRunMutation) RunCleared() bool {
	return m.clearedrun
}

// RunID returns the run id in the mutation.
func (m *StepRunMutation) RunID() (id string, exists bool) {
	if m.run != nil {
		return *m.run, true
	}
	return
}

// RunIDs returns the run ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *StepRunMutation) RunIDs() (ids []string) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun reset all changes of the "run" edge.
func (m *StepRunMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// Op returns the operation name.
func (m *StepRunMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StepRun).
func (m *StepRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StepRunMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, steprun.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, steprun.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, steprun.FieldStatus)
	}
	if m.startedAt != nil {
		fields = append(fields, steprun.FieldStartedAt)
	}
	if m.endedAt != nil {
		fields = append(fields, steprun.FieldEndedAt)
	}
	if m.index != nil {
		fields = append(fields, steprun.FieldIndex)
	}
	if m.participantsCount != nil {
		fields = append(fields, steprun.FieldParticipantsCount)
	}
	if m.hitID != nil {
		fields = append(fields, steprun.FieldHitID)
	}
	if m.urlToken != nil {
		fields = append(fields, steprun.FieldUrlToken)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StepRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case steprun.FieldCreatedAt:
		return m.CreatedAt()
	case steprun.FieldUpdatedAt:
		return m.UpdatedAt()
	case steprun.FieldStatus:
		return m.Status()
	case steprun.FieldStartedAt:
		return m.StartedAt()
	case steprun.FieldEndedAt:
		return m.EndedAt()
	case steprun.FieldIndex:
		return m.Index()
	case steprun.FieldParticipantsCount:
		return m.ParticipantsCount()
	case steprun.FieldHitID:
		return m.HitID()
	case steprun.FieldUrlToken:
		return m.UrlToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StepRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case steprun.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case steprun.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case steprun.FieldStatus:
		return m.OldStatus(ctx)
	case steprun.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case steprun.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case steprun.FieldIndex:
		return m.OldIndex(ctx)
	case steprun.FieldParticipantsCount:
		return m.OldParticipantsCount(ctx)
	case steprun.FieldHitID:
		return m.OldHitID(ctx)
	case steprun.FieldUrlToken:
		return m.OldUrlToken(ctx)
	}
	return nil, fmt.Errorf("unknown StepRun field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StepRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case steprun.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case steprun.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case steprun.FieldStatus:
		v, ok := value.(steprun.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case steprun.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case steprun.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case steprun.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case steprun.FieldParticipantsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantsCount(v)
		return nil
	case steprun.FieldHitID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHitID(v)
		return nil
	case steprun.FieldUrlToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrlToken(v)
		return nil
	}
	return fmt.Errorf("unknown StepRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StepRunMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, steprun.FieldIndex)
	}
	if m.addparticipantsCount != nil {
		fields = append(fields, steprun.FieldParticipantsCount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StepRunMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case steprun.FieldIndex:
		return m.AddedIndex()
	case steprun.FieldParticipantsCount:
		return m.AddedParticipantsCount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StepRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	case steprun.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case steprun.FieldParticipantsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParticipantsCount(v)
		return nil
	}
	return fmt.Errorf("unknown StepRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StepRunMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(steprun.FieldStartedAt) {
		fields = append(fields, steprun.FieldStartedAt)
	}
	if m.FieldCleared(steprun.FieldEndedAt) {
		fields = append(fields, steprun.FieldEndedAt)
	}
	if m.FieldCleared(steprun.FieldHitID) {
		fields = append(fields, steprun.FieldHitID)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StepRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StepRunMutation) ClearField(name string) error {
	switch name {
	case steprun.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case steprun.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	case steprun.FieldHitID:
		m.ClearHitID()
		return nil
	}
	return fmt.Errorf("unknown StepRun nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StepRunMutation) ResetField(name string) error {
	switch name {
	case steprun.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case steprun.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case steprun.FieldStatus:
		m.ResetStatus()
		return nil
	case steprun.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case steprun.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case steprun.FieldIndex:
		m.ResetIndex()
		return nil
	case steprun.FieldParticipantsCount:
		m.ResetParticipantsCount()
		return nil
	case steprun.FieldHitID:
		m.ResetHitID()
		return nil
	case steprun.FieldUrlToken:
		m.ResetUrlToken()
		return nil
	}
	return fmt.Errorf("unknown StepRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StepRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.createdParticipants != nil {
		edges = append(edges, steprun.EdgeCreatedParticipants)
	}
	if m.participants != nil {
		edges = append(edges, steprun.EdgeParticipants)
	}
	if m.participations != nil {
		edges = append(edges, steprun.EdgeParticipations)
	}
	if m.step != nil {
		edges = append(edges, steprun.EdgeStep)
	}
	if m.run != nil {
		edges = append(edges, steprun.EdgeRun)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StepRunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case steprun.EdgeCreatedParticipants:
		ids := make([]ent.Value, 0, len(m.createdParticipants))
		for id := range m.createdParticipants {
			ids = append(ids, id)
		}
		return ids
	case steprun.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case steprun.EdgeParticipations:
		ids := make([]ent.Value, 0, len(m.participations))
		for id := range m.participations {
			ids = append(ids, id)
		}
		return ids
	case steprun.EdgeStep:
		if id := m.step; id != nil {
			return []ent.Value{*id}
		}
	case steprun.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StepRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcreatedParticipants != nil {
		edges = append(edges, steprun.EdgeCreatedParticipants)
	}
	if m.removedparticipants != nil {
		edges = append(edges, steprun.EdgeParticipants)
	}
	if m.removedparticipations != nil {
		edges = append(edges, steprun.EdgeParticipations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StepRunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case steprun.EdgeCreatedParticipants:
		ids := make([]ent.Value, 0, len(m.removedcreatedParticipants))
		for id := range m.removedcreatedParticipants {
			ids = append(ids, id)
		}
		return ids
	case steprun.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case steprun.EdgeParticipations:
		ids := make([]ent.Value, 0, len(m.removedparticipations))
		for id := range m.removedparticipations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StepRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreatedParticipants {
		edges = append(edges, steprun.EdgeCreatedParticipants)
	}
	if m.clearedparticipants {
		edges = append(edges, steprun.EdgeParticipants)
	}
	if m.clearedparticipations {
		edges = append(edges, steprun.EdgeParticipations)
	}
	if m.clearedstep {
		edges = append(edges, steprun.EdgeStep)
	}
	if m.clearedrun {
		edges = append(edges, steprun.EdgeRun)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StepRunMutation) EdgeCleared(name string) bool {
	switch name {
	case steprun.EdgeCreatedParticipants:
		return m.clearedcreatedParticipants
	case steprun.EdgeParticipants:
		return m.clearedparticipants
	case steprun.EdgeParticipations:
		return m.clearedparticipations
	case steprun.EdgeStep:
		return m.clearedstep
	case steprun.EdgeRun:
		return m.clearedrun
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StepRunMutation) ClearEdge(name string) error {
	switch name {
	case steprun.EdgeStep:
		m.ClearStep()
		return nil
	case steprun.EdgeRun:
		m.ClearRun()
		return nil
	}
	return fmt.Errorf("unknown StepRun unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StepRunMutation) ResetEdge(name string) error {
	switch name {
	case steprun.EdgeCreatedParticipants:
		m.ResetCreatedParticipants()
		return nil
	case steprun.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case steprun.EdgeParticipations:
		m.ResetParticipations()
		return nil
	case steprun.EdgeStep:
		m.ResetStep()
		return nil
	case steprun.EdgeRun:
		m.ResetRun()
		return nil
	}
	return fmt.Errorf("unknown StepRun edge %s", name)
}

// TemplateMutation represents an operation that mutate the Templates
// nodes in the graph.
type TemplateMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	selectionType       *template.SelectionType
	participantCount    *int
	addparticipantCount *int
	internalCriteria    *[]byte
	mturkCriteria       *[]byte
	adult               *bool
	sandbox             *bool
	clearedFields       map[string]struct{}
	steps               map[string]struct{}
	removedsteps        map[string]struct{}
	clearedsteps        bool
	project             *string
	clearedproject      bool
	creator             *string
	clearedcreator      bool
	run                 *string
	clearedrun          bool
	done                bool
	oldValue            func(context.Context) (*Template, error)
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows to manage the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for $n.Name.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the id field of the mutation.
func withTemplateID(id string) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Template creation.
func (m *TemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *TemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *TemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *TemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *TemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *TemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *TemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetSelectionType sets the selectionType field.
func (m *TemplateMutation) SetSelectionType(tt template.SelectionType) {
	m.selectionType = &tt
}

// SelectionType returns the selectionType value in the mutation.
func (m *TemplateMutation) SelectionType() (r template.SelectionType, exists bool) {
	v := m.selectionType
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectionType returns the old selectionType value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldSelectionType(ctx context.Context) (v template.SelectionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelectionType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelectionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectionType: %w", err)
	}
	return oldValue.SelectionType, nil
}

// ResetSelectionType reset all changes of the "selectionType" field.
func (m *TemplateMutation) ResetSelectionType() {
	m.selectionType = nil
}

// SetParticipantCount sets the participantCount field.
func (m *TemplateMutation) SetParticipantCount(i int) {
	m.participantCount = &i
	m.addparticipantCount = nil
}

// ParticipantCount returns the participantCount value in the mutation.
func (m *TemplateMutation) ParticipantCount() (r int, exists bool) {
	v := m.participantCount
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantCount returns the old participantCount value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldParticipantCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParticipantCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParticipantCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantCount: %w", err)
	}
	return oldValue.ParticipantCount, nil
}

// AddParticipantCount adds i to participantCount.
func (m *TemplateMutation) AddParticipantCount(i int) {
	if m.addparticipantCount != nil {
		*m.addparticipantCount += i
	} else {
		m.addparticipantCount = &i
	}
}

// AddedParticipantCount returns the value that was added to the participantCount field in this mutation.
func (m *TemplateMutation) AddedParticipantCount() (r int, exists bool) {
	v := m.addparticipantCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetParticipantCount reset all changes of the "participantCount" field.
func (m *TemplateMutation) ResetParticipantCount() {
	m.participantCount = nil
	m.addparticipantCount = nil
}

// SetInternalCriteria sets the internalCriteria field.
func (m *TemplateMutation) SetInternalCriteria(b []byte) {
	m.internalCriteria = &b
}

// InternalCriteria returns the internalCriteria value in the mutation.
func (m *TemplateMutation) InternalCriteria() (r []byte, exists bool) {
	v := m.internalCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalCriteria returns the old internalCriteria value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldInternalCriteria(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalCriteria is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalCriteria: %w", err)
	}
	return oldValue.InternalCriteria, nil
}

// ResetInternalCriteria reset all changes of the "internalCriteria" field.
func (m *TemplateMutation) ResetInternalCriteria() {
	m.internalCriteria = nil
}

// SetMturkCriteria sets the mturkCriteria field.
func (m *TemplateMutation) SetMturkCriteria(b []byte) {
	m.mturkCriteria = &b
}

// MturkCriteria returns the mturkCriteria value in the mutation.
func (m *TemplateMutation) MturkCriteria() (r []byte, exists bool) {
	v := m.mturkCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldMturkCriteria returns the old mturkCriteria value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldMturkCriteria(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMturkCriteria is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMturkCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMturkCriteria: %w", err)
	}
	return oldValue.MturkCriteria, nil
}

// ResetMturkCriteria reset all changes of the "mturkCriteria" field.
func (m *TemplateMutation) ResetMturkCriteria() {
	m.mturkCriteria = nil
}

// SetAdult sets the adult field.
func (m *TemplateMutation) SetAdult(b bool) {
	m.adult = &b
}

// Adult returns the adult value in the mutation.
func (m *TemplateMutation) Adult() (r bool, exists bool) {
	v := m.adult
	if v == nil {
		return
	}
	return *v, true
}

// OldAdult returns the old adult value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldAdult(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdult is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdult: %w", err)
	}
	return oldValue.Adult, nil
}

// ResetAdult reset all changes of the "adult" field.
func (m *TemplateMutation) ResetAdult() {
	m.adult = nil
}

// SetSandbox sets the sandbox field.
func (m *TemplateMutation) SetSandbox(b bool) {
	m.sandbox = &b
}

// Sandbox returns the sandbox value in the mutation.
func (m *TemplateMutation) Sandbox() (r bool, exists bool) {
	v := m.sandbox
	if v == nil {
		return
	}
	return *v, true
}

// OldSandbox returns the old sandbox value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldSandbox(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSandbox is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSandbox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSandbox: %w", err)
	}
	return oldValue.Sandbox, nil
}

// ResetSandbox reset all changes of the "sandbox" field.
func (m *TemplateMutation) ResetSandbox() {
	m.sandbox = nil
}

// AddStepIDs adds the steps edge to Step by ids.
func (m *TemplateMutation) AddStepIDs(ids ...string) {
	if m.steps == nil {
		m.steps = make(map[string]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the steps edge to Step.
func (m *TemplateMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared returns if the edge steps was cleared.
func (m *TemplateMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the steps edge to Step by ids.
func (m *TemplateMutation) RemoveStepIDs(ids ...string) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[string]struct{})
	}
	for i := range ids {
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed ids of steps.
func (m *TemplateMutation) RemovedStepsIDs() (ids []string) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the steps ids in the mutation.
func (m *TemplateMutation) StepsIDs() (ids []string) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps reset all changes of the "steps" edge.
func (m *TemplateMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// SetProjectID sets the project edge to Project by id.
func (m *TemplateMutation) SetProjectID(id string) {
	m.project = &id
}

// ClearProject clears the project edge to Project.
func (m *TemplateMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared returns if the edge project was cleared.
func (m *TemplateMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the project id in the mutation.
func (m *TemplateMutation) ProjectID() (id string, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the project ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) ProjectIDs() (ids []string) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject reset all changes of the "project" edge.
func (m *TemplateMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetCreatorID sets the creator edge to Admin by id.
func (m *TemplateMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the creator edge to Admin.
func (m *TemplateMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared returns if the edge creator was cleared.
func (m *TemplateMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the creator id in the mutation.
func (m *TemplateMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the creator ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator reset all changes of the "creator" edge.
func (m *TemplateMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetRunID sets the run edge to Run by id.
func (m *TemplateMutation) SetRunID(id string) {
	m.run = &id
}

// ClearRun clears the run edge to Run.
func (m *TemplateMutation) ClearRun() {
	m.clearedrun = true
}

// RunCleared returns if the edge run was cleared.
func (m *TemplateMutation) RunCleared() bool {
	return m.clearedrun
}

// RunID returns the run id in the mutation.
func (m *TemplateMutation) RunID() (id string, exists bool) {
	if m.run != nil {
		return *m.run, true
	}
	return
}

// RunIDs returns the run ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) RunIDs() (ids []string) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun reset all changes of the "run" edge.
func (m *TemplateMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, template.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.selectionType != nil {
		fields = append(fields, template.FieldSelectionType)
	}
	if m.participantCount != nil {
		fields = append(fields, template.FieldParticipantCount)
	}
	if m.internalCriteria != nil {
		fields = append(fields, template.FieldInternalCriteria)
	}
	if m.mturkCriteria != nil {
		fields = append(fields, template.FieldMturkCriteria)
	}
	if m.adult != nil {
		fields = append(fields, template.FieldAdult)
	}
	if m.sandbox != nil {
		fields = append(fields, template.FieldSandbox)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldCreatedAt:
		return m.CreatedAt()
	case template.FieldUpdatedAt:
		return m.UpdatedAt()
	case template.FieldName:
		return m.Name()
	case template.FieldSelectionType:
		return m.SelectionType()
	case template.FieldParticipantCount:
		return m.ParticipantCount()
	case template.FieldInternalCriteria:
		return m.InternalCriteria()
	case template.FieldMturkCriteria:
		return m.MturkCriteria()
	case template.FieldAdult:
		return m.Adult()
	case template.FieldSandbox:
		return m.Sandbox()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case template.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldSelectionType:
		return m.OldSelectionType(ctx)
	case template.FieldParticipantCount:
		return m.OldParticipantCount(ctx)
	case template.FieldInternalCriteria:
		return m.OldInternalCriteria(ctx)
	case template.FieldMturkCriteria:
		return m.OldMturkCriteria(ctx)
	case template.FieldAdult:
		return m.OldAdult(ctx)
	case template.FieldSandbox:
		return m.OldSandbox(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case template.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldSelectionType:
		v, ok := value.(template.SelectionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectionType(v)
		return nil
	case template.FieldParticipantCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantCount(v)
		return nil
	case template.FieldInternalCriteria:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalCriteria(v)
		return nil
	case template.FieldMturkCriteria:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMturkCriteria(v)
		return nil
	case template.FieldAdult:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdult(v)
		return nil
	case template.FieldSandbox:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSandbox(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TemplateMutation) AddedFields() []string {
	var fields []string
	if m.addparticipantCount != nil {
		fields = append(fields, template.FieldParticipantCount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case template.FieldParticipantCount:
		return m.AddedParticipantCount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case template.FieldParticipantCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParticipantCount(v)
		return nil
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TemplateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case template.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldSelectionType:
		m.ResetSelectionType()
		return nil
	case template.FieldParticipantCount:
		m.ResetParticipantCount()
		return nil
	case template.FieldInternalCriteria:
		m.ResetInternalCriteria()
		return nil
	case template.FieldMturkCriteria:
		m.ResetMturkCriteria()
		return nil
	case template.FieldAdult:
		m.ResetAdult()
		return nil
	case template.FieldSandbox:
		m.ResetSandbox()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.steps != nil {
		edges = append(edges, template.EdgeSteps)
	}
	if m.project != nil {
		edges = append(edges, template.EdgeProject)
	}
	if m.creator != nil {
		edges = append(edges, template.EdgeCreator)
	}
	if m.run != nil {
		edges = append(edges, template.EdgeRun)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	case template.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case template.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case template.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsteps != nil {
		edges = append(edges, template.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsteps {
		edges = append(edges, template.EdgeSteps)
	}
	if m.clearedproject {
		edges = append(edges, template.EdgeProject)
	}
	if m.clearedcreator {
		edges = append(edges, template.EdgeCreator)
	}
	if m.clearedrun {
		edges = append(edges, template.EdgeRun)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeSteps:
		return m.clearedsteps
	case template.EdgeProject:
		return m.clearedproject
	case template.EdgeCreator:
		return m.clearedcreator
	case template.EdgeRun:
		return m.clearedrun
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	case template.EdgeProject:
		m.ClearProject()
		return nil
	case template.EdgeCreator:
		m.ClearCreator()
		return nil
	case template.EdgeRun:
		m.ClearRun()
		return nil
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeSteps:
		m.ResetSteps()
		return nil
	case template.EdgeProject:
		m.ResetProject()
		return nil
	case template.EdgeCreator:
		m.ResetCreator()
		return nil
	case template.EdgeRun:
		m.ResetRun()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}
